{
  "destructuring of props": {
    "prefix": "dp",
    "body": ["const { ${1:name} } = this.props"]
  },
  "destructuring of state": {
    "prefix": "ds",
    "body": ["const { ${1:name} } = this.state"]
  },
  "react function component with props": {
    "prefix": "rfcp",
    "body": "import React from 'react'\n\ntype ${1:Type} ={\n\t${2:val}: ${3}\n}\nexport default function ${TM_FILENAME_BASE}: React.FC<${1}>({${2}}) {\n\treturn (\n\t\t<div>\n\t\t\t{$2}\n\t\t</div>\n\t\t)\n\t}\n}\n\n",
    "description": "Creates a React component with props"
  },
  "FunctionComponent": {
    "prefix": "rfce",
    "body": "import React from 'react'\n\nexport default function ${TM_FILENAME_BASE}() {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}",
    "description": "Creates a React functional component without PropTypes"
  },
  "classConstructor": {
    "prefix": "con",
    "body": "constructor (props) {\n\tsuper(props)\n\t$0\n}\n",
    "description": "Adds a default constructor for the class that contains props as arguments"
  },
  "classConstructorContext": {
    "prefix": "conc",
    "body": "constructor (props, context) {\n\tsuper(props, context)\n\t$0\n}\n",
    "description": "Adds a default constructor for the class that contains props and context as arguments"
  },
  "componentWillMount": {
    "prefix": "cwm",
    "body": "\ncomponentWillMount () {\n\t$0\n}\n",
    "description": "Invoked once, both on the client and server, immediately before the initial rendering occurs"
  },
  "componentDidMount": {
    "prefix": "cdm",
    "body": "componentDidMount () {\n\t$0\n}\n",
    "description": "Invoked once, only on the client (not on the server), immediately after the initial rendering occurs."
  },
  "componentWillReceiveProps": {
    "prefix": "cwr",
    "body": "componentWillReceiveProps (nextProps) {\n\t$0\n}\n",
    "description": "Invoked when a component is receiving new props. This method is not called for the initial render."
  },
  "componentGetDerivedStateFromProps": {
    "prefix": "cgd",
    "body": "\nstatic getDerivedStateFromProps(nextProps, prevState) {\n\t$0\n}\n",
    "description": "Invoked after a component is instantiated as well as when it receives new props. It should return an object to update state, or null to indicate that the new props do not require any state updates."
  },
  "shouldComponentUpdate": {
    "prefix": "scu",
    "body": "shouldComponentUpdate (nextProps, nextState) {\n\t$0\n}\n",
    "description": "Invoked before rendering when new props or state are being received. "
  },
  "componentWillUpdate": {
    "prefix": "cwup",
    "body": "componentWillUpdate (nextProps, nextState) {\n\t$0\n}\n",
    "description": "Invoked immediately before rendering when new props or state are being received."
  },
  "componentDidUpdate": {
    "prefix": "cdup",
    "body": "componentDidUpdate (prevProps, prevState) {\n\t$0\n}\n",
    "description": "Invoked immediately after the component's updates are flushed to the DOM."
  },
  "componentWillUnmount": {
    "prefix": "cwun",
    "body": "componentWillUnmount () {\n\t$0\n}\n",
    "description": "Invoked immediately before a component is unmounted from the DOM."
  },
  "componentRender": {
    "prefix": "ren",
    "body": "render () {\n\treturn (\n\t\t<div>\n\t\t\t$0\n\t\t</div>\n\t)\n}",
    "description": "When called, it should examine this.props and this.state and return a single child element."
  },
  "componentSetStateObject": {
    "prefix": "sst",
    "body": "this.setState($0)",
    "description": "Performs a shallow merge of nextState into current state"
  },
  "componentSetStateFunc": {
    "prefix": "ssf",
    "body": "this.setState((state, props) => { return { $0 }})\n",
    "description": "Performs a shallow merge of nextState into current state"
  },
  "componentProps": {
    "prefix": "tp",
    "body": "this.props.$0",
    "description": "Access component's props"
  },
  "componentState": {
    "prefix": "ts",
    "body": "this.state.$0",
    "description": "Access component's state"
  },
  "propTypes": {
    "prefix": "rpt",
    "body": "$1.propTypes = {\n\t$2\n}",
    "description": "Creates empty propTypes declaration"
  },
  "propTypeArray": {
    "prefix": "pta",
    "body": "PropTypes.array,",
    "description": "Array prop type"
  },
  "propTypeArrayRequired": {
    "prefix": "ptar",
    "body": "PropTypes.array.isRequired,",
    "description": "Array prop type required"
  },
  "propTypeBool": {
    "prefix": "ptb",
    "body": "PropTypes.bool,",
    "description": "Bool prop type"
  },
  "propTypeBoolRequired": {
    "prefix": "ptbr",
    "body": "PropTypes.bool.isRequired,",
    "description": "Bool prop type required"
  },
  "propTypeFunc": {
    "prefix": "ptf",
    "body": "PropTypes.func,",
    "description": "Func prop type"
  },
  "propTypeFuncRequired": {
    "prefix": "ptfr",
    "body": "PropTypes.func.isRequired,",
    "description": "Func prop type required"
  },
  "propTypeNumber": {
    "prefix": "ptn",
    "body": "PropTypes.number,",
    "description": "Number prop type"
  },
  "propTypeNumberRequired": {
    "prefix": "ptnr",
    "body": "PropTypes.number.isRequired,",
    "description": "Number prop type required"
  },
  "propTypeObject": {
    "prefix": "pto",
    "body": "PropTypes.object,",
    "description": "Object prop type"
  },
  "propTypeObjectRequired": {
    "prefix": "ptor",
    "body": "PropTypes.object.isRequired,",
    "description": "Object prop type required"
  },
  "propTypeString": {
    "prefix": "pts",
    "body": "PropTypes.string,",
    "description": "String prop type"
  },
  "propTypeStringRequired": {
    "prefix": "ptsr",
    "body": "PropTypes.string.isRequired,",
    "description": "String prop type required"
  },
  "propTypeNode": {
    "prefix": "ptnd",
    "body": "PropTypes.node,",
    "description": "Anything that can be rendered: numbers, strings, elements or an array"
  },
  "propTypeNodeRequired": {
    "prefix": "ptndr",
    "body": "PropTypes.node.isRequired,",
    "description": "Anything that can be rendered: numbers, strings, elements or an array required"
  },
  "propTypeElement": {
    "prefix": "ptel",
    "body": "PropTypes.element,",
    "description": "React element prop type"
  },
  "propTypeElementRequired": {
    "prefix": "ptelr",
    "body": "PropTypes.element.isRequired,",
    "description": "React element prop type required"
  },
  "propTypeInstanceOf": {
    "prefix": "pti",
    "body": "PropTypes.instanceOf($0),",
    "description": "Is an instance of a class prop type"
  },
  "propTypeInstanceOfRequired": {
    "prefix": "ptir",
    "body": "PropTypes.instanceOf($0).isRequired,",
    "description": "Is an instance of a class prop type required"
  },
  "propTypeEnum": {
    "prefix": "pte",
    "body": "PropTypes.oneOf(['$0']),",
    "description": "Prop type limited to specific values by treating it as an enum"
  },
  "propTypeEnumRequired": {
    "prefix": "pter",
    "body": "PropTypes.oneOf(['$0']).isRequired,",
    "description": "Prop type limited to specific values by treating it as an enum required"
  },
  "propTypeOneOfType": {
    "prefix": "ptet",
    "body": "PropTypes.oneOfType([\n\t$0\n]),",
    "description": "An object that could be one of many types"
  },
  "propTypeOneOfTypeRequired": {
    "prefix": "ptetr",
    "body": "PropTypes.oneOfType([\n\t$0\n]).isRequired,",
    "description": "An object that could be one of many types required"
  },
  "propTypeArrayOf": {
    "prefix": "ptao",
    "body": "PropTypes.arrayOf($0),",
    "description": "An array of a certain type"
  },
  "propTypeArrayOfRequired": {
    "prefix": "ptaor",
    "body": "PropTypes.arrayOf($0).isRequired,",
    "description": "An array of a certain type required"
  },
  "propTypeObjectOf": {
    "prefix": "ptoo",
    "body": "PropTypes.objectOf($0),",
    "description": "An object with property values of a certain type"
  },
  "propTypeObjectOfRequired": {
    "prefix": "ptoor",
    "body": "PropTypes.objectOf($0).isRequired,",
    "description": "An object with property values of a certain type required"
  },
  "propTypeShape": {
    "prefix": "ptsh",
    "body": "PropTypes.shape({\n\t$0\n}),",
    "description": "An object taking on a particular shape"
  },
  "propTypeShapeRequired": {
    "prefix": "ptshr",
    "body": "PropTypes.shape({\n\t$0\n}).isRequired,",
    "description": "An object taking on a particular shape required"
  },
  "jsx element": {
    "prefix": "j",
    "body": "<${1:elementName}>\n\t$0\n</${1}>",
    "description": "an element"
  },
  "jsx element self closed": {
    "prefix": "jc",
    "body": "<${1:elementName} />",
    "description": "an element self closed"
  },
  "jsx elements map": {
    "prefix": "jm",
    "body": "{${1:array}.map((item, id) => <div key={item.id}>\n\t$0\n</div>)}",
    "description": "an element self closed"
  },
  "jsx elements map with return": {
    "prefix": "jmr",
    "body": "{${1:array}.map((item, id) => {\n\treturn <div key={id}>\n\t$0\n</div>\n})}",
    "description": "an element self closed"
  },
  "useState": {
    "prefix": "us",
    "body": "const [${1:setterName}, set${1}] = useState(${2})$0",
    "description": "use state hook"
  },
  "useState any value": {
    "prefix": "us any",
    "body": "const [${1:val}, set${1}] = useState<null | ${2}>(null)",
    "description": "use state hook"
  },
  "useEffect": {
    "prefix": "ue",
    "body": ["useEffect(() => {", "\t$1", "}, [])$0"],
    "description": "React useEffect() hook"
  },
  "useEffect with cleanup": {
    "prefix": "uec",
    "body": [
      "useEffect(() => {",
      "\t$1",
      "\n\treturn () => {",
      "\t\t$2",
      "\t}",
      "}, [])$0"
    ],
    "description": "React useEffect() hook with a cleanup function"
  },
  "createContext": {
    "prefix": "cc",
    "body": [
      "export const $1 = createContext<$2>(",
      "\t(null as any) as $2",
      ")"
    ],
    "description": "creates a react context"
  },
  "useContext": {
    "prefix": "uc",
    "body": ["const $1 = useContext($2)$0"],
    "description": "React useContext() hook"
  },
  "useRef": {
    "prefix": "ur",
    "body": ["const ${1:elName}El = useRef(null)$0"],
    "description": "React useContext() hook"
  },
  "useCallback": {
    "prefix": "ucb",
    "body": [
      "const ${1:memoizedCallback} = useCallback(",
      "\t() => {",
      "\t\t${2:doSomething}(${3:a}, ${4:b})",
      "\t},",
      "\t[${5:a}, ${6:b}],",
      ")$0"
    ],
    "description": "React useCallback() hook"
  },
  "useMemo": {
    "prefix": "ume",
    "body": [
      "const ${1:memoizedValue} = useMemo(() => ${2:computeExpensiveValue}(${3:a}, ${4:b}), [${5:a}, ${6:b}])$0"
    ],
    "description": "React useMemo() hook"
  },
  "toggle menu navbar": {
    "prefix": "menu",
    "body": [
      "const [ menu, setMenu ] = useState(false)",
      "const handleMenu = () => setMenu(!menu)"
    ]
  },
  "zustant create": {
    "prefix": "zustand create",
    "body": [
      "import { create } from \"zustand\";",
      "import { persist } from \"zustand/middleware\";",
      "\ntype Store = {\n\tcount: number\n}",
      "export const store = create<Store>(\n\tpersist(\n\t\t(set: void) => (\n\t\t\tcount: 0,\n\t\t}),\n\t\t{ name: 'storage' }","\t)",");"
    ]
  },
  "zustand store": {
    "prefix": "zustand store",
    "body": [
      "import { store } from \"$1\"",
      "import { shallow } from \"zustand/shallow\"\n",
      "interface State {\n\t${2}: ${3}\n\t${4}: ${5}\n}",
      "const [${2:val1}, ${3:val2}] = store((state: State) => {\n\treturn [state.${2}, state.${4}];\n}, shallow);"
    ]
  },
	"Import": {
		"prefix": "import",
		"body": [
			"import $1 from \"${2}\";"
		],
		"description": "Import "
	},
	"Import external module.": {
		"prefix": "import statement",
		"body": [
			"import { $1 } from \"${2}\";"
		],
		"description": "Import external module."
	},
  "interface":{
    "prefix": "interface",
    "body": "interface ${1} {\n\t${2:val}: ${3:type}\n}"
  },
  "interface extends":{
    "prefix": "interface extends",
    "body": "interface $1 extends $2 "
  },
  "children":{
    "prefix": "children",
    "body": "type Children = {\n\tchildren: React.ReactNode\n}\n"
  },
  "event click":{
    "prefix": "event click",
    "body": "event: React.MouseEvent<HTMLButtonElement>"
  },
  "event prevent":{
    "prefix": "event prevent",
    "body": "event.preventDefault()"
  },
  "event form":{
    "prefix": "event get value",
    "body": "event: React.ChangeEvent<HTMLInputlement>"
  },
  "hook useInput create":{
    "prefix":"useInput create",
    "body":"import React, { useState } from \"react\"\n\nexport interface UseInput {\n\tvalue: string;\n\tonChange: (event: React.ChangeEvent<HTMLInputElement>) => void;\n}\nexport const useInput = (initial: string): UseInput => {\n\tconst [value, setValue] = useState(initial);\n\tconst onChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n\t\tsetValue(event.target.value);\n\t}\n\t\n\treturn {\n\t\tvalue,\n\t\tonChange,\n\t}\n}"
  },
  "hook useInput store":{
    "prefix":"useInput store",
    "body":"import React from \"react\"\nimport { useInput } from \"${1}\"\n\nexport default function ${TM_FILENAME_BASE}(){\n\tconst nameInput = useInput(\"\")\n\tconst emailInput = useInput(\"\")\n\n\tconst handleSubmit = (event: React.FormEvent) => {\n\t\tevent.preventDefault();\n\n\t\tconsole.log(nameInput.value)\n\t}\n\n\treturn (\n\t\t<form onSubmit={handleSubmit}>\n\t\t\t<input type=\"text\" {...nameInput} />\n\t\t\t<button>Submit</button>\n\t\t</form>\n\t)\n}"
  },
  "className":{
    "prefix":"className",
    "body": "className=\"${1}\""
  },
  "useFetch hook create": {
    "prefix":"useFetch create",
    "body":"import { useState, useEffect } from \"react\"\n\nexport const useFetch = (url: string) => {\n\tconst [data, setData] = useState<boolean | null>(null);\n\tconst [loading, setLoading] = useState(true);\n\tconst [error, setError] = useState<string | null>(null);\n\n\tuseEffect(() => {\n\t\tconst fetchData = async () => {\n\t\t\ttry {\n\t\t\t\tconst res = await fetch(url);\n\t\t\t\tif (!res.ok) {\n\t\t\t\t\tthrow new Error(\"Fetch failed\");\n\t\t\t\t}\n\n\t\t\t\tconst data = await res.json();\n\n\t\t\t\tsetData(data);\n\t\t\t\tsetLoading(false);\n\t\t\t} catch (error) {\n\t\t\t\tsetError(error);\n\t\t\t\tsetLoading(false);\n\t\t\t}\n\t\t}\n\t\tfetchData();\n\t},[url]);\n\n\treturn {\n\t\tdata,\n\t\tloading,\n\t\terror,\n\t}\n}"
  },
  "useFetch hook store":{
    "prefix":"useFetch store",
    "body":"const { data, loading, error } = useFetch(\"${1}\")\nloading && <p>loading</p>\nerror && <p>{error.message}</p>"
  }
}
